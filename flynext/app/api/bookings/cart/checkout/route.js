// The below code is generated by Claude 3.7

// app/api/bookings/cart/checkout/route.js
import { NextResponse } from "next/server";
import { authenticate } from "@/utils/auth";
import { bookFlights, validateCreditCard, validateFlight, checkRoomAvailability } from "@/utils/bookingUtils";
import { createBookingNotifications } from "@/utils/notificationUtils";
import prisma from "@/utils/db";

export async function POST(request) {
  let flightConfirmation = null;
  let bookingReference = null;
  
  try {
    // Authenticate the user
    const userId = await authenticate(request);
    if (!userId) {
      return NextResponse.json(
        { error: "Authentication required" },
        { status: 401 }
      );
    }

    // Parse request body
    let data;
    try {
      data = await request.json();
    } catch (parseError) {
      return NextResponse.json(
        { error: "Invalid JSON in request body" },
        { status: 400 }
      );
    }
    
    const { bookingId, paymentInfo } = data;
    
    if (!bookingId) {
      return NextResponse.json(
        { error: "Booking ID is required" },
        { status: 400 }
      );
    }

    // Validate payment information
    if (!paymentInfo || !validateCreditCard(paymentInfo)) {
      return NextResponse.json(
        { error: "Invalid payment information" },
        { status: 400 }
      );
    }

    // Validate passenger information
    if (!paymentInfo.passengerInfo) {
      return NextResponse.json(
        { error: "Passenger information is required" },
        { status: 400 }
      );
    }

    const passengerInfo = paymentInfo.passengerInfo;
    if (!passengerInfo.firstName || !passengerInfo.lastName || 
        !passengerInfo.email || !passengerInfo.passportNumber) {
      return NextResponse.json(
        { error: "Complete passenger information is required (firstName, lastName, email, passportNumber)" },
        { status: 400 }
      );
    }

    // Ensure passport number is exactly 9 characters
    if (passengerInfo.passportNumber.length !== 9) {
      return NextResponse.json(
        { error: "Passport number must be exactly 9 characters" },
        { status: 400 }
      );
    }

    // Fetch the booking with its items
    const booking = await prisma.booking.findUnique({
      where: { 
        id: bookingId,
        userId
      },
      include: {
        bookingFlights: true,
        bookingRooms: {
          include: {
            room: true
          }
        },
        hotel: true
      }
    });

    if (!booking) {
      return NextResponse.json(
        { error: "Booking not found or doesn't belong to you" },
        { status: 404 }
      );
    }

    if (booking.status !== "pending") {
      return NextResponse.json(
        { error: "Only pending bookings can be checked out" },
        { status: 400 }
      );
    }

    // Check if there's anything to book
    if (booking.bookingFlights.length === 0 && booking.bookingRooms.length === 0) {
      return NextResponse.json(
        { error: "Booking is empty. Add at least one flight or room before checkout" },
        { status: 400 }
      );
    }

    // Process flights if any
    if (booking.bookingFlights.length > 0) {
      // Validate each flight before booking
      const unavailableFlights = [];
      
      for (const bf of booking.bookingFlights) {
        try {          
          // Use the validateFlight function with stored origin, destination, and date
          await validateFlight(bf.flightId);
        } catch (validationError) {
          // If validation fails, add to the list of unavailable flights
          unavailableFlights.push({
            id: bf.id,
            flightId: bf.flightId,
            error: validationError.message
          });
        }
      }
      
      // If any flights are unavailable, return error with details
      if (unavailableFlights.length > 0) {
        return NextResponse.json({
          error: "Some flights are no longer available",
          unavailableFlights,
          message: "Please remove the unavailable flights from your booking and try again."
        }, { status: 409 }); // Conflict status code
      }
      
      // Extract flight IDs for booking
      const flightIds = booking.bookingFlights.map(bf => bf.flightId);
      
      try {
        // Book the flights with AFS
        flightConfirmation = await bookFlights(flightIds, passengerInfo);
        bookingReference = flightConfirmation.bookingReference;
        
        // Update the booking flights one by one
        for (const bf of booking.bookingFlights) {
          await prisma.bookingFlight.update({
            where: { id: bf.id },
            data: {
              bookingReference: flightConfirmation.bookingReference,
              status: "confirmed"
            }
          });
        }
      } catch (error) {
        // Parse AFS API error response
        let cleanErrorMessage = "Flight booking failed";
        
        try {
          const errorMsg = error.message || String(error);
          if (errorMsg.includes('{') && errorMsg.includes('}')) {
            const jsonStart = errorMsg.indexOf('{');
            const jsonEnd = errorMsg.lastIndexOf('}') + 1;
            const jsonString = errorMsg.substring(jsonStart, jsonEnd);
            
            const errorData = JSON.parse(jsonString);
            
            if (errorData.error) {
              if (errorData.error.includes("No available seats on flight")) {
                const flightId = errorData.error.split("No available seats on flight ")[1];
                cleanErrorMessage = `No seats available on the selected flight (${flightId})`;
              } else {
                cleanErrorMessage = errorData.error;
              }
            }
          }
        } catch (parseError) {
          cleanErrorMessage = error.message || String(error);
        }
        
        return NextResponse.json(
          { error: "Checkout failed", details: cleanErrorMessage },
          { status: 500 }
        );
      }
    }
    
    // Process hotel rooms if any and calculate price
    let totalRoomPrice = 0;
    if (booking.bookingRooms.length > 0) {
      // Calculate nights
      const checkIn = booking.checkIn;
      const checkOut = booking.checkOut;
      
      if (!checkIn || !checkOut) {
        throw new Error("Check-in and check-out dates are required for hotel bookings");
      }
      
      const nights = Math.ceil((checkOut - checkIn) / (1000 * 60 * 60 * 24));
      if (nights <= 0) {
        throw new Error("Check-out date must be after check-in date");
      }
      
      // Check if any rooms are unavailable
      const unavailableRooms = [];
      
      // Process each room one by one
      for (const br of booking.bookingRooms) {
        try {
          // Check room availability using our new function
          const isAvailable = await checkRoomAvailability(
            br.roomId, 
            checkIn, 
            checkOut, 
            br.quantity
          );
          
          if (!isAvailable) {
            unavailableRooms.push({
              id: br.id,
              roomId: br.roomId,
              type: br.room.type,
              quantity: br.quantity,
              error: "Not enough rooms available for the selected dates"
            });
            continue;
          }
          
          // Get room details
          const room = await prisma.room.findUnique({
            where: { id: br.roomId }
          });
          
          if (!room) {
            throw new Error(`Room with ID ${br.roomId} not found`);
          }
          
          // Update room booking status
          await prisma.bookingRoom.update({
            where: { id: br.id },
            data: {
              status: "confirmed"
            }
          });
          
          // Calculate price for this room
          const roomPrice = parseFloat(room.pricePerNight);
          totalRoomPrice += roomPrice * br.quantity * nights;
          
        } catch (error) {
          unavailableRooms.push({
            id: br.id,
            roomId: br.roomId,
            type: br.room?.type || "Unknown",
            quantity: br.quantity,
            error: error.message
          });
        }
      }
      
      // If any rooms are unavailable, return error with details
      if (unavailableRooms.length > 0) {
        // If we've already booked flights, we need to handle this differently
        if (flightConfirmation) {
          return NextResponse.json({
            warning: "Flight booking completed but room booking failed",
            flightBookingReference: bookingReference,
            flightConfirmation: flightConfirmation,
            unavailableRooms,
            message: "Your flights were booked successfully, but some rooms are no longer available. Please update your room selection and try again."
          }, { status: 207 }); // 207 Multi-Status
        }
        
        return NextResponse.json({
          error: "Some rooms are no longer available",
          unavailableRooms,
          message: "Please update your room selection and try again."
        }, { status: 409 }); // Conflict status code
      }
    }
    
    // Calculate total price
    let totalPrice = totalRoomPrice;
    if (flightConfirmation?.flights) {
      for (const flight of flightConfirmation.flights) {
        totalPrice += flight.price;
      }
    }
    
    // Update the booking status and total price
    const updatedBooking = await prisma.booking.update({
      where: { id: bookingId },
      data: {
        status: "confirmed",
        paymentStatus: "success",
        totalPrice: totalPrice.toString()
      },
      include: {
        bookingFlights: true,
        bookingRooms: {
          include: {
            room: true
          }
        },
        hotel: true
      }
    });
    
    // Try to create notifications (but continue if it fails)
    try {
      await createBookingNotifications(
        { userId, flightBooking: flightConfirmation, hotelBookings: [{ hotelId: booking.hotelId }] },
        bookingId
      );
    } catch (notifError) {
      console.log("Failed to create notifications");
    }
    
    // Try to create a log entry (but continue if it fails)
    try {
      await prisma.log.create({
        data: {
          userId,
          action: `Completed booking: ${bookingId}`
        }
      });
    } catch (logError) {
      console.log("Failed to create log entry");
    }
    
    // Return success response
    return NextResponse.json({
      message: "Booking checkout completed successfully",
      booking: updatedBooking,
      flightConfirmation,
      totalPrice: parseFloat(updatedBooking.totalPrice)
    });
    
  } catch (error) {
    // Special case: if we have a flight booking but database failed
    if (flightConfirmation && bookingReference) {
      return NextResponse.json({
        warning: "Booking partially completed - database update failed",
        message: "Your flight was booked successfully, but we had trouble updating our database. Please contact support with your booking reference.",
        flightBookingReference: bookingReference,
        flightConfirmation: flightConfirmation,
        error: String(error)
      }, { status: 207 }); // 207 Multi-Status
    }
    
    // Regular error handling
    let errorMessage = "An error occurred during checkout";
    
    try {
      if (error && typeof error === 'object' && 'message' in error) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }
      
      // Remove any redundant prefixes
      if (errorMessage.includes("Flight booking failed: Flight booking failed:")) {
        errorMessage = errorMessage.replace("Flight booking failed: Flight booking failed:", "Flight booking failed:");
      }
      
      console.log("Checkout error:", errorMessage);
    } catch (e) {
      // Do nothing if even the logging fails
    }
    
    return NextResponse.json(
      { error: "Checkout failed", details: errorMessage },
      { status: 500 }
    );
  }
}