// The below code is generated by DeepSeek R1

// app/api/flights/search/route.js
import prisma from "@/utils/db";
import { NextResponse } from "next/server";

export async function GET(request) {
  /*
    USER STORY FROM PROJECT DESCRIPTION:
    "As a visitor, I want to search for flights by specifying a source, 
    destination, and date(s). Source and destination could be either a city or 
    an airport. I want to search for one-way or round-trip flights."

    IMPLEMENTATION: 
    This endpoint will handle only one-way flights. The frontend will handle 
    round-trips by calling this api twice for outbound and return using both 
    the dates(s) (departure date and return date).
  */
  try {
    const { searchParams } = new URL(request.url);
    const origin = searchParams.get("origin");
    const destination = searchParams.get("destination");
    const date = searchParams.get("date");

    if (!origin || !destination || !date) {
      return NextResponse.json(
        { error: "Missing required parameters: origin, destination, or date" },
        { status: 400 }
      );
    }

    // Validate date format
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      return NextResponse.json(
        { error: "Invalid date format. Use YYYY-MM-DD" },
        { status: 400 }
      );
    }

    // Check if inputs are valid cities or airports
    const [originResult, destinationResult] = await Promise.all([
      prisma.$transaction([
        prisma.city.findFirst({
          where: { name: origin },
          select: { name: true }
        }),
        prisma.airport.findFirst({
          where: { code: origin },
          select: { code: true }
        })
      ]),
      prisma.$transaction([
        prisma.city.findFirst({
          where: { name: destination },
          select: { name: true }
        }),
        prisma.airport.findFirst({
          where: { code: destination },
          select: { code: true }
        })
      ])
    ]);

    if (!(originResult[0] || originResult[1]) || !(destinationResult[0] || destinationResult[1])) {
      return NextResponse.json(
        { error: "Invalid origin or destination" },
        { status: 400 }
      );
    }

    // Build AFS API URL
    const afsUrl = new URL("https://advanced-flights-system.replit.app/api/flights");
    afsUrl.searchParams.append("origin", origin);
    afsUrl.searchParams.append("destination", destination);
    afsUrl.searchParams.append("date", date);

    // Fetch from AFS API
    const response = await fetch(afsUrl, {
      headers: {
        "x-api-key": process.env.AFS_API_KEY,
      }
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`AFS API Error: ${error}`);
    }

    const data = await response.json();

    // Transform response if needed
    const results = data.results.map(result => ({
      ...result,
      flights: result.flights.map(flight => ({
        ...flight,
        price: Number(flight.price),
        duration: Number(flight.duration),
        availableSeats: Number(flight.availableSeats)
      }))
    }));

    // Log the search
    await prisma.log.create({
      data: {
        action: `FLIGHT_SEARCH: ${origin}->${destination} on ${date}`,
      }
    });

    return NextResponse.json({ results });

  } catch (error) {
    await prisma.log.create({
      data: {
        action: `FLIGHT_SEARCH_ERROR: ${error.message}`,
        level: "ERROR"
      }
    });
    return NextResponse.json(
      { error: error.message || "Failed to fetch flights" },
      { status: 500 }
    );
  }
}