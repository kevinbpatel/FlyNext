// The below code is generated by Claude 3.7

// utils/bookingUtils.js
import prisma from "@/utils/db";

/**
 * Book flights through the Advanced Flight System (AFS)
 * @param {string[]} flightIds - Array of flight IDs to book
 * @param {Object} passengerInfo - Passenger information (firstName, lastName, email, passportNumber)
 * @returns {Promise<Object>} - AFS booking confirmation
 * @throws {Error} - If the booking fails for any reason
 */
export async function bookFlights(flightIds, passengerInfo) {
  // Validate inputs thoroughly
  if (!flightIds || !Array.isArray(flightIds) || flightIds.length === 0) {
    throw new Error("Valid flight IDs array is required");
  }
  
  if (!passengerInfo || typeof passengerInfo !== 'object') {
    throw new Error("Passenger information must be a valid object");
  }
  
  const { firstName, lastName, email, passportNumber } = passengerInfo;
  
  if (!firstName || !lastName || !email || !passportNumber) {
    throw new Error("Complete passenger information (firstName, lastName, email, passportNumber) is required");
  }
  
  if (passportNumber.length !== 9) {
    throw new Error("Passport number must be exactly 9 characters");
  }
  
  // Verify API key
  if (!process.env.AFS_API_KEY) {
    throw new Error("AFS API key is not configured. Please check your environment variables.");
  }
  
  try {
    // Log request info for debugging
    console.log(`Booking flights with IDs: ${JSON.stringify(flightIds)}`);
    console.log(`Passenger: ${firstName} ${lastName}, Email: ${email}`);
    
    // Construct payload
    const requestBody = JSON.stringify({
      firstName,
      lastName,
      email,
      passportNumber,
      flightIds
    });
    
    console.log(`Request payload: ${requestBody}`);
    
    // Call AFS API
    const afsResponse = await fetch("https://advanced-flights-system.replit.app/api/bookings", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": process.env.AFS_API_KEY
      },
      body: requestBody
    });
    
    // Handle API response
    let responseText = "";
    try {
      responseText = await afsResponse.text();
    } catch (e) {
      console.error("Failed to read AFS response text:", e);
    }
    
    if (!afsResponse.ok) {
      console.error("AFS API Error Response:", responseText);
      throw new Error(`Flight booking failed: ${responseText}`);
    }
    
    // Parse response if we have one
    if (!responseText) {
      throw new Error("Empty response from AFS API");
    }
    
    try {
      const bookingData = JSON.parse(responseText);
      console.log("Flight booking successful:", bookingData.bookingReference);
      return bookingData;
    } catch (parseError) {
      console.error("Failed to parse AFS API response:", parseError);
      throw new Error("Invalid JSON response from AFS API");
    }
  } catch (error) {
    // Create a safe error message
    const errorMessage = error instanceof Error ? error.message : "Unknown flight booking error";
    console.error("Flight booking error:", errorMessage);
    throw new Error(errorMessage);
  }
}

/**
 * Book hotel rooms within a transaction
 * @param {string} hotelId - Hotel ID
 * @param {Array} rooms - Array of room bookings with roomId and quantity
 * @param {Date} checkIn - Check-in date
 * @param {Date} checkOut - Check-out date
 * @param {string} userId - User ID
 * @param {PrismaClient.TransactionClient} tx - Prisma transaction client 
 * @returns {Promise<Object>} - Hotel booking with all associated data
 */
export async function bookHotel(hotelId, rooms, checkIn, checkOut, userId, tx) {
  // Use the transaction client if provided, otherwise use regular prisma client
  const client = tx || prisma;
  
  if (!hotelId || !rooms?.length) return null;
  
  // Verify rooms are available in sufficient quantity
  for (const roomBooking of rooms) {
    const room = await client.room.findUnique({
      where: { id: roomBooking.roomId }
    });
    
    if (!room) {
      throw new Error(`Room with ID ${roomBooking.roomId} not found`);
    }
    
    if (room.availableRooms < roomBooking.quantity) {
      throw new Error(`Not enough available rooms of type ${room.type}. Requested: ${roomBooking.quantity}, Available: ${room.availableRooms}`);
    }
  }
  
  // Calculate nights for the stay
  const nights = Math.ceil((checkOut - checkIn) / (1000 * 60 * 60 * 24));
  if (nights <= 0) {
    throw new Error("Check-out date must be after check-in date");
  }
  
  // Create booking with room bookings
  const booking = await client.booking.create({
    data: {
      userId,
      hotelId,
      checkIn,
      checkOut,
      totalPrice: 0, // Will update after calculating
      status: "confirmed",
      paymentStatus: "success",
      bookingRooms: {
        create: rooms.map(room => ({
          roomId: room.roomId,
          quantity: room.quantity
        }))
      }
    },
    include: {
      bookingRooms: {
        include: {
          room: true
        }
      },
      hotel: true
    }
  });
  
  // Calculate total price
  let totalPrice = 0;
  for (const bookingRoom of booking.bookingRooms) {
    const roomPrice = parseFloat(bookingRoom.room.pricePerNight);
    totalPrice += roomPrice * bookingRoom.quantity * nights;
    
    // Update room availability
    await client.room.update({
      where: { id: bookingRoom.roomId },
      data: {
        availableRooms: {
          decrement: bookingRoom.quantity
        }
      }
    });
  }
  
  // Update booking with total price
  const updatedBooking = await client.booking.update({
    where: { id: booking.id },
    data: {
      totalPrice
    },
    include: {
      bookingRooms: {
        include: {
          room: true
        }
      },
      hotel: true
    }
  });
  
  return updatedBooking;
}

/**
 * Calculates total price for a booking combining flights and hotel
 * @param {Object} flightBooking - Flight booking confirmation from AFS
 * @param {Object} hotelBooking - Hotel booking from database
 * @returns {number} - Total price of the booking
 */
export function calculateTotalItineraryPrice(flightBooking, hotelBooking) {
  let total = 0;
  
  // Add flight prices
  if (flightBooking?.flights) {
    for (const flight of flightBooking.flights) {
      total += flight.price;
    }
  }
  
  // Add hotel price if present
  if (hotelBooking) {
    total += parseFloat(hotelBooking.totalPrice);
  }
  
  return total;
}

/**
 * Verify a flight booking with AFS
 * @param {string} bookingReference - AFS booking reference
 * @param {string} lastName - Passenger last name
 * @returns {Promise<Object>} - Verified booking details
 */
export async function verifyFlightBooking(bookingReference, lastName) {
  try {
    // Call AFS API to verify the booking
    const verifyResponse = await fetch(
      `https://advanced-flights-system.replit.app/api/bookings/retrieve?bookingReference=${bookingReference}&lastName=${lastName}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": process.env.AFS_API_KEY,
        }
      }
    );
    
    if (!verifyResponse.ok) {
      const errorData = await verifyResponse.text();
      console.error("AFS Verification Error:", errorData);
      throw new Error(`Flight verification failed: ${errorData}`);
    }
    
    return await verifyResponse.json();
  } catch (error) {
    console.error("Flight verification error:", error);
    throw error;
  }
}

/**
 * Cancel a booking or specific parts of a booking using a transaction
 * @param {string} bookingId - Booking ID
 * @param {Object} cancellationOptions - What to cancel (all, flights, specific rooms)
 * @param {string} userId - User ID for permission check
 * @returns {Promise<Object>} - Updated booking
 */
export async function cancelBooking(bookingId, cancellationOptions, userId) {
  // First verify the booking exists and belongs to the user
  const booking = await prisma.booking.findUnique({
    where: { id: bookingId },
    include: {
      bookingRooms: {
        include: {
          room: true
        }
      },
      bookingFlights: true,
      hotel: true
    }
  });
  
  if (!booking) {
    throw new Error("Booking not found");
  }
  
  if (booking.userId !== userId) {
    throw new Error("You do not have permission to cancel this booking");
  }
  
  // Check if booking is already canceled
  if (booking.status === "canceled") {
    throw new Error("Booking is already canceled");
  }
  
  const { cancelAll, cancelFlights, cancelRooms } = cancellationOptions;
  
  // Use transaction to ensure all operations succeed or fail together
  return await prisma.$transaction(async (tx) => {
    // Cancel entire booking
    if (cancelAll) {
      // Update room availability
      for (const bookingRoom of booking.bookingRooms) {
        await tx.room.update({
          where: { id: bookingRoom.roomId },
          data: {
            availableRooms: {
              increment: bookingRoom.quantity
            }
          }
        });
      }
      
      // Update booking status
      const updatedBooking = await tx.booking.update({
        where: { id: bookingId },
        data: {
          status: "canceled"
        },
        include: {
          bookingRooms: {
            include: {
              room: true
            }
          },
          bookingFlights: true,
          hotel: true
        }
      });
      
      // Create a notification for the user
      await tx.notification.create({
        data: {
          userId,
          message: `Your booking (${bookingId}) has been canceled.`,
          isRead: false
        }
      });
      
      // Log the cancellation
      await tx.log.create({
        data: {
          userId,
          action: `Canceled booking: ${bookingId}`
        }
      });
      
      return updatedBooking;
    }
    
    // Cancel specific rooms (partial cancellation)
    if (cancelRooms && cancelRooms.length > 0) {
      for (const roomId of cancelRooms) {
        const bookingRoom = booking.bookingRooms.find(br => br.roomId === roomId);
        
        if (bookingRoom) {
          // Restore room availability
          await tx.room.update({
            where: { id: roomId },
            data: {
              availableRooms: {
                increment: bookingRoom.quantity
              }
            }
          });
          
          // Delete the booking room
          await tx.bookingRoom.delete({
            where: { id: bookingRoom.id }
          });
        }
      }
    }
    
    // Check if there are any rooms left after cancellation
    const remainingRooms = await tx.bookingRoom.count({
      where: { bookingId }
    });
    
    // If no rooms left and no flights, cancel the entire booking
    if (remainingRooms === 0 && (!booking.bookingFlights || booking.bookingFlights.length === 0 || cancelFlights)) {
      await tx.booking.update({
        where: { id: bookingId },
        data: {
          status: "canceled"
        }
      });
    }
    
    // Create a notification for the user
    await tx.notification.create({
      data: {
        userId,
        message: `Parts of your booking (${bookingId}) have been canceled.`,
        isRead: false
      }
    });
    
    // Log the partial cancellation
    await tx.log.create({
      data: {
        userId,
        action: `Partially canceled booking: ${bookingId}`
      }
    });
    
    // Return the updated booking
    return await tx.booking.findUnique({
      where: { id: bookingId },
      include: {
        bookingRooms: {
          include: {
            room: true
          }
        },
        bookingFlights: true,
        hotel: true
      }
    });
  }, {
    maxWait: 5000,
    timeout: 10000,
    isolationLevel: "Serializable"
  });
}

/**
 * Get suggested hotels based on flight destination
 * @param {string} destinationCity - Destination city name
 * @param {Date} checkIn - Arrival date
 * @param {Date} checkOut - Departure date
 * @returns {Promise<Array>} - List of suggested hotels
 */
export async function getSuggestedHotels(destinationCity, checkIn, checkOut) {
  try {
    // Get city ID for the destination
    const city = await prisma.city.findFirst({
      where: {
        name: destinationCity
      }
    });
    
    if (!city) {
      return [];
    }
    
    // Find hotels in the destination city with available rooms
    const hotels = await prisma.hotel.findMany({
      where: {
        cityId: city.id,
        rooms: {
          some: {
            availableRooms: { gt: 0 }
          }
        }
      },
      include: {
        rooms: {
          where: {
            availableRooms: { gt: 0 }
          }
        },
        city: true
      },
      take: 3 // Limit to 3 suggestions
    });
    
    return hotels;
  } catch (error) {
    console.error("Error getting hotel suggestions:", error);
    throw error;
  }
}

/**
 * Get suggested flights based on hotel location
 * @param {string} originCity - Origin city
 * @param {string} hotelCity - Hotel city
 * @param {Date} arrivalDate - Desired arrival date
 * @param {Date} departureDate - Desired departure date
 * @returns {Promise<Object>} - List of suggested flights
 */
export async function getSuggestedFlights(originCity, hotelCity, arrivalDate, departureDate) {
  try {
    // Format dates for AFS API
    const formattedArrivalDate = formatDateForAFS(arrivalDate);
    const formattedDepartureDate = formatDateForAFS(departureDate);
    
    // Get outbound flights (to hotel)
    const outboundResponse = await fetch(
      `https://advanced-flights-system.replit.app/api/flights?origin=${originCity}&destination=${hotelCity}&date=${formattedArrivalDate}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": process.env.AFS_API_KEY,
        }
      }
    );
    
    if (!outboundResponse.ok) {
      console.error("Error fetching outbound flights");
      return { outbound: [], return: [] };
    }
    
    const outboundData = await outboundResponse.json();
    
    // Get return flights (from hotel)
    const returnResponse = await fetch(
      `https://advanced-flights-system.replit.app/api/flights?origin=${hotelCity}&destination=${originCity}&date=${formattedDepartureDate}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": process.env.AFS_API_KEY,
        }
      }
    );
    
    if (!returnResponse.ok) {
      console.error("Error fetching return flights");
      return { outbound: outboundData.results?.slice(0, 2) || [], return: [] };
    }
    
    const returnData = await returnResponse.json();
    
    // Return the top 2 options for each direction (limit suggestions)
    return {
      outbound: outboundData.results?.slice(0, 2) || [],
      return: returnData.results?.slice(0, 2) || []
    };
  } catch (error) {
    console.error("Error getting flight suggestions:", error);
    throw error;
  }
}

/**
 * Validate credit card details
 * @param {Object} cardInfo - Credit card information
 * @returns {boolean} - Is the card valid
 */
export function validateCreditCard(cardInfo) {
  const { number, name, expiryMonth, expiryYear, cvv } = cardInfo;
  
  // Validate card number (simple Luhn algorithm for credit card validation)
  if (!luhnCheck(number)) {
    return false;
  }
  
  // Validate expiry date
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1; // JavaScript months are 0-indexed
  
  if (parseInt(expiryYear) < currentYear || 
      (parseInt(expiryYear) === currentYear && parseInt(expiryMonth) < currentMonth)) {
    return false;
  }
  
  // Validate CVV (should be 3-4 digits)
  if (!/^\d{3,4}$/.test(cvv)) {
    return false;
  }
  
  // Validate name (should not be empty)
  if (!name || name.trim() === '') {
    return false;
  }
  
  return true;
}

/**
 * Implementation of the Luhn algorithm for credit card validation
 * @param {string} cardNumber - Credit card number
 * @returns {boolean} - Is the card number valid
 */
function luhnCheck(cardNumber) {
  // Remove all non-digit characters
  const value = cardNumber.replace(/\D/g, '');
  
  // Check if the card number has a valid length
  if (value.length < 13 || value.length > 19) {
    return false;
  }
  
  let sum = 0;
  let shouldDouble = false;
  
  // Loop through values starting from the right
  for (let i = value.length - 1; i >= 0; i--) {
    let digit = parseInt(value.charAt(i));
    
    if (shouldDouble) {
      digit *= 2;
      if (digit > 9) digit -= 9;
    }
    
    sum += digit;
    shouldDouble = !shouldDouble;
  }
  
  return (sum % 10) === 0;
}

/**
 * Helper function to format dates for AFS API
 * @param {Date} date - Date to format
 * @returns {string} - Formatted date string (YYYY-MM-DD)
 */
function formatDateForAFS(date) {
  return date.toISOString().split('T')[0];
}

/**
 * Calculate total price for an itinerary
 * @param {Object} flightBooking - Flight booking information
 * @param {Object} hotelBooking - Hotel booking information
 * @returns {number} - Total price
 */
function calculateTotalPrice(flightBooking, hotelBooking) {
  let total = 0;
  
  // Add flight prices
  if (flightBooking?.flights) {
    for (const flight of flightBooking.flights) {
      total += flight.price;
    }
  }
  
  // Add hotel price if present
  if (hotelBooking) {
    total += parseFloat(hotelBooking.totalPrice);
  }
  
  return total;
}

/**
 * Generate a random booking reference
 * @returns {string} - Booking reference
 */
function generateBookingReference() {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}


/**
 * Validates a flight by checking if it exists, has seats, and is scheduled
 * @param {string} flightId - ID of the flight to validate
 * @returns {Promise<Object>} - Flight details or throws error if validation fails
 */
export async function validateFlight(flightId) {
  // Validate inputs
  if (!flightId) {
    throw new Error("Flight ID is required");
  }

  try {
    // Directly fetch the flight by ID
    const response = await fetch(`https://advanced-flights-system.replit.app/api/flights/${flightId}`, {
      headers: {
        "x-api-key": process.env.AFS_API_KEY,
      }
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`AFS API Error: ${error}`);
    }

    const flight = await response.json();
    
    // Check seats availability
    if (flight.availableSeats <= 0) {
      throw new Error("No available seats on this flight");
    }
    
    // Check flight status
    if (flight.status !== "SCHEDULED") {
      throw new Error(`Flight is ${flight.status.toLowerCase()}, not scheduled`);
    }
    
    // Return flight details if all validation passes
    return {
      id: flight.id,
      flightNumber: flight.flightNumber,
      airline: flight.airline.name,
      origin: flight.origin.code,
      destination: flight.destination.code,
      departureTime: flight.departureTime,
      arrivalTime: flight.arrivalTime,
      price: flight.price,
      availableSeats: flight.availableSeats,
      status: flight.status,
      originDetails: flight.origin,
      destinationDetails: flight.destination,
      airlineDetails: flight.airline
    };
  } catch (error) {
    // Handle fetch errors or JSON parsing errors
    if (error.message.includes("AFS API Error")) {
      throw error;
    }
    throw new Error(`Failed to validate flight: ${error.message}`);
  }
}


/**
 * Checks if a room is available for the given date range and quantity
 * @param {string} roomId - Room ID to check
 * @param {Date} checkInDate - Check-in date
 * @param {Date} checkOutDate - Check-out date
 * @param {number} requestedQuantity - Number of rooms requested
 * @returns {Promise<boolean>} - True if rooms are available, false otherwise
 */
export async function checkRoomAvailability(roomId, checkInDate, checkOutDate, requestedQuantity) {
  // Get the room with all its bookings
  const room = await prisma.room.findUnique({
    where: { id: roomId },
    include: {
      bookingRooms: {
        include: {
          booking: true
        }
      }
    }
  });

  if (!room) {
    throw new Error("Room not found");
  }

  // Total number of this type of room in the hotel
  const totalRoomsAvailable = room.availableRooms;

  // Get all dates in the stay period
  const stayDates = getDatesArray(checkInDate, checkOutDate);

  // Check availability for each date
  for (const date of stayDates) {
    // Sum up confirmed bookings for this date
    const bookedRoomsForDate = room.bookingRooms
      .filter(br => {
        const booking = br.booking;
        // Only count confirmed bookings that overlap with this date
        return booking.status === "confirmed" &&
               booking.checkIn && booking.checkOut &&
               date >= booking.checkIn && date < booking.checkOut;
      })
      .reduce((sum, br) => sum + br.quantity, 0);

    // Calculate remaining rooms for this date
    const remainingRooms = totalRoomsAvailable - bookedRoomsForDate;

    // Check if enough rooms are available
    if (remainingRooms < requestedQuantity) {
      return false;
    }
  }

  return true;
}

/**
 * Helper function to get array of dates between start and end (inclusive of start, exclusive of end)
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @returns {Array<Date>} - Array of dates
 */
function getDatesArray(startDate, endDate) {
  const datesArray = [];
  const currentDate = new Date(startDate);
  
  // Set time to beginning of day for consistent comparison
  currentDate.setHours(0, 0, 0, 0);
  
  const endDateCopy = new Date(endDate);
  endDateCopy.setHours(0, 0, 0, 0);
  
  while (currentDate < endDateCopy) {
    datesArray.push(new Date(currentDate));
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  return datesArray;
}