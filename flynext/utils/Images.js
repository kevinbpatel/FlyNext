// The below code is generated by ChatGPT o3-mini-high

import { publicDecrypt } from "crypto";
import fs from "fs";
import path from "path";

/**
 * Save uploaded images for a hotel.
 * @param {Buffer} imageBuffer - The image blob data as a buffer.
 * @param {string} hotelId - The unique ID of the hotel.
 * @param {string} fileName - Original file name (to keep extensions).
 * @returns {string} - The stored file path (relative to `/uploads/`).
 */
export const saveHotelImage = (imageBuffer, hotelId, fileName) => {
  try {
    // Define hotel image directory: /upload/hotel/{hotelId}/images/
    const hotelImageDir = path.join(process.cwd(),"public", "upload", "hotel_personal", hotelId, "images_hotel");

    // Ensure the directory exists
    if (!fs.existsSync(hotelImageDir)) {
      fs.mkdirSync(hotelImageDir, { recursive: true }); // Create directories recursively
    }

    // Generate a unique filename to prevent conflicts
    const fileExt = path.extname(fileName);
    const uniqueFileName = `${Date.now()}-${fileName.replace(/\s+/g, "_")}`;
    const filePath = path.join(hotelImageDir, uniqueFileName);

    // Save the image file
    fs.writeFileSync(filePath, imageBuffer);

    // Return the relative path (to be stored in the database)
    return `/upload/hotel_personal/${hotelId}/images_hotel/${uniqueFileName}`;
  } catch (error) {
    console.error("Error saving hotel image:", error);
    return null;
  }
};


export const saveRoomImage = (imageBuffer, hotelId, roomId, fileName) => {
  try {
    // ✅ Define room image directory: /public/upload/hotel/{hotelId}/rooms/{roomId}/images/
    const roomImageDir = path.join(
      process.cwd(),
      "public",
      "upload",
      "hotel_personal",
      hotelId,
      "rooms_personal",
      roomId,
      "images_room"
    );

    // ✅ Ensure the directory exists
    if (!fs.existsSync(roomImageDir)) {
      fs.mkdirSync(roomImageDir, { recursive: true }); // Create directories recursively
    }

    // ✅ Generate a unique filename to prevent conflicts
    const fileExt = path.extname(fileName);
    const uniqueFileName = `${Date.now()}-${fileName.replace(/\s+/g, "_")}`;
    const filePath = path.join(roomImageDir, uniqueFileName);

    // ✅ Save the image file
    fs.writeFileSync(filePath, imageBuffer);

    // ✅ Return the relative path (to be stored in the database)
    return `/upload/hotel_personal/${hotelId}/rooms_personal/${roomId}/images_room/${uniqueFileName}`;
  } catch (error) {
    console.error("Error saving room image:", error);
    return null;
  }
};


export const deleteHotelImage = (imagePath) => {
  try {
    const absolutePath = path.join(process.cwd(), "public", imagePath);

    if (fs.existsSync(absolutePath)) {
      fs.unlinkSync(absolutePath); // Delete the file
      console.log(`Deleted: ${absolutePath}`);
    }
  } catch (error) {
    console.error("Error deleting hotel image:", error);
  }
};



export const deleteRoomImage = (imagePath) => {
  try {
    const absolutePath = path.join(process.cwd(), "public", imagePath);

    if (fs.existsSync(absolutePath)) {
      fs.unlinkSync(absolutePath); // Delete the file
      console.log(`Deleted: ${absolutePath}`);
    }
  } catch (error) {
    console.error("Error deleting room image:", error);
  }
};

/**
 * Save uploaded profile picture for a user.
 * @param {Buffer} imageBuffer - The image blob data as a buffer.
 * @param {string} userId - The unique ID of the user.
 * @param {string} fileName - Original file name (to keep extensions).
 * @returns {string} - The stored file path (relative to `/uploads/`).
 */
export const saveProfileImage = (imageBuffer, userId, fileName) => {
  try {
    // Define profile image directory: /public/upload/user/{userId}/profile/
    const profileImageDir = path.join(
      process.cwd(),
      "public",
      "upload",
      "user_pictures",
      userId,
      "profile_pictures"
    );
    
    // Ensure the directory exists
    if (!fs.existsSync(profileImageDir)) {
      fs.mkdirSync(profileImageDir, { recursive: true }); // Create directories recursively
    }
    
    // Generate a unique filename to prevent conflicts
    const fileExt = path.extname(fileName);
    const uniqueFileName = `${Date.now()}-${fileName.replace(/\s+/g, "_")}`;
    const filePath = path.join(profileImageDir, uniqueFileName);
    
    // Save the image file
    fs.writeFileSync(filePath, imageBuffer);
    
    // Return the relative path (to be stored in the database)
    console.log("Saved file to:", filePath);
    console.log("Returning URL:", `/upload/user_pictures/${userId}/profile_pictures/${uniqueFileName}`);

    return `/upload/user_pictures/${userId}/profile_pictures/${uniqueFileName}`;
  } catch (error) {
    console.error("Error saving profile image:", error);
    return null;
  }
};

/**
 * Delete a user's profile image file.
 * @param {string} imagePath - The path to the image file.
 */
export const deleteProfileImage = (imagePath) => {
  try {
    // Don't delete if it's the default profile picture
    if (imagePath && imagePath.includes('default-profile.png')) {
      return;
    }
    
    const absolutePath = path.join(process.cwd(), "public", imagePath);
    
    if (fs.existsSync(absolutePath)) {
      fs.unlinkSync(absolutePath); // Delete the file
      console.log(`Deleted profile image: ${absolutePath}`);
    }
  } catch (error) {
    console.error("Error deleting profile image:", error);
  }
};

/**
 * Get the default profile image path.
 * @returns {string} - Path to the default profile image.
 */
export const getDefaultProfileImage = () => {
  return '/images/default-profile.png';
};
